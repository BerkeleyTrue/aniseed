= Aniseed

Aniseed bridges the gap between https://fennel-lang.org/[Fennel] (a Lisp that compiles to Lua) and https://neovim.io/[Neovim]. Allowing you to easily write plugins or configuration in a https://clojure.org/[Clojure]-like Lisp with great runtime performance.

https://asciinema.org/a/326401[image:https://asciinema.org/a/326401.svg[asciicast]]

Further documentation can be found in link:doc/aniseed.txt[`:help aniseed`].

== Installation

Use your favourite plugin manager, I recommend https://github.com/junegunn/vim-plug[vim-plug] if you don't have one already.

[source,viml]
----
Plug 'Olical/aniseed', { 'tag': 'v3.3.0' }
Plug 'bakpakin/fennel.vim'
----

For interactive evaluation you need to install https://github.com/Olical/conjure[Conjure]. It'll allow you to send portions of your code off for evaluation as well as see the results in an interactive log buffer.

You may also be interested in https://github.com/Olical/nvim-local-fennel[nvim-local-fennel] which is essentially a Fennel based version of https://github.com/embear/vim-localvimrc[localvimrc].

== Module macros

Lua and Fennel require you to use `(local ...)` and `(fn ...)` as well as a table as the last value in your file to define modules. This leads to inconsistent syntax and having to jump up and down in the buffer to keep your module's table in sync with what you want to expose.

This unstructured approach also makes it really hard (maybe impossible?) to have an interactive REPL driven work flow. We want to be able to say in a structured way "here's what my module is called, here's what it requires and here's what it defines".

Aniseed makes the following macros available to you which will allow you to write modules in a structured way using the evaluation mappings described previously. Let's get the most interesting and complex one out of the way first, the rest are just different ways of defining things.

=== `(module NAME [REQUIRES] [BASE])`

Define a module under the name given by the first argument, this should be the first form in your file. The module name should match the path to the source file with the slashes replaced with periods.

So `fnl/my-plugin/features/backflip.fnl` would start with `(module my-plugin.features.backflip)`. By using the period syntax we get to build paths that work on any OS, even if their path separator varies from what we're used to.

The requires are a table where the key is the function you want executed (`require` or `include`) and the values are tables of aliases and module names. Let's take our previous module example and require a utility module into it under an alias of `util`.

[source,clojure]
----
(module my-plugin.features.backflip
  {require {util my-plugin.util}})

(util.do-thing)
----

____
You're not limited to just `require` or `include`, any function name will do. If you write a special `require` called `require-py` that compiles Python to Lua and loads it, you can use that too!
____

The final argument can be used in rare scenarios where you want to build your module upon another Lua module which may not be related to Aniseed or Fennel in any way. Let's say you want to take a Lua library, wrap it with an Aniseed module and add some function to it.

[source,clojure]
----
(module my-plugin.math {} (include :some-awesome-lua-math-lib))

(defn inc [x]
  (+ x 1))
----

Now we have a module that inherits from a Lua module but extends it with an extra function. You probably won't need this, but it's handy when you do! Aniseed actually uses it internally to wrap the `nvim.lua` library.

=== The `(def...)` family

The `def...` macros help you define values or functions publicly or privately. Every `def` macro can be suffixed with a hyphen to keep it private, like `(def- ten 10)`.

 * `(def NAME VALUE)` - just like `local` or `var` but Aniseed is now aware of the value and will allow you to refer to it in subsequent evaluations of forms within that module.
 * `(defonce NAME VALUE)` - the same as `def` but will only define once. Subsequent evaluations of this form will do nothing. This is great for keeping process IDs from background jobs between evaluations.
 * `(defn NAME ARGS ...)` - translates to `(def NAME (fn ARGS ...))`, so it's just like the regular `(fn ...)` form really.
 * `(deftest NAME ...)` - explained in greater detail in the testing section.

== Standard library

Aniseed provides a fair few functions that it uses internally but are designed for use by plugin authors. The best way to discover these is to delve into `fnl/aniseed` and have a look through the source, anything that isn't self explanatory has a documentation string attached to it.

[source,clojure]
----
(module foo
  {require {a aniseed.core
            str aniseed.string}})

(defn- add [a b]
  (+ a b))

(->> [1 2 3]
     (a.map a.inc)
     (a.reduce add 0))
;; => 9

(str.join ", " [1 2 3])
;; => "1, 2, 3"
----

And here's some more useful modules you'll probably want to check out.

 * `aniseed.nvim` is actually https://github.com/norcalli/nvim.lua[nvim.lua], an extremely helpful library for controlling Neovim with a more expressive syntax.
 * `aniseed.eval` allows you to run more Fennel code through Aniseed.
 * `aniseed.compile` lets you compile strings and files of Fennel into Lua.

== Use case 1: Writing your dotfiles in Fennel

My Neovim https://github.com/Olical/dotfiles/tree/master/neovim/.config/nvim[dotfiles] are written in Fennel using Aniseed, all you need to do is add the following to your `init.vim`.

[source,viml]
----
lua require('aniseed.dotfiles')
----

Now try adding some Fennel, such as the example below, to `~/.config/nvim/fnl/dotfiles/init.fnl`. The next time you open Neovim you'll see `"Hello!"`.

[source,clojure]
----
(module dotfiles.init
  {require {a aniseed.core}})

(a.pr "Hello!")
----

This will write the compiled Lua into `~/.config/nvim/lua`, it's only recompiled if the Fennel changes. You'll want to add the `lua` directory to your `.gitignore` if your dotfiles are in git.

You can continue to add more files under `fnl/dotfiles` and require them using the `module` macro syntax.

== Use case 2: Compiling a plugin ahead of time

https://github.com/Olical/nvim-local-fennel[nvim-local-fennel] and the experimental https://github.com/Olical/conjure-sourcery[conjure-sourcery] should be good examples of Fennel based plugins (I hope so, I wrote them), here's how to create something new.

We'll start by fetching the `dep.sh` helper script which we'll use to clone and update Aniseed. It can be used for repos other than Aniseed, use and modify it as you see fit.

[source,bash]
----
mkdir -p scripts
curl https://raw.githubusercontent.com/Olical/aniseed/master/scripts/dep.sh -o scripts/dep.sh
chmod +x scripts/dep.sh
----

Now let's clone Aniseed into `deps/aniseed`, be sure to `.gitignore` the `deps` directory. I keep my `dep.sh` calls in my `Makefile` so I can run `make deps` to synchronise anything that's required.

[source,bash]
----
scripts/dep.sh Olical aniseed vX.Y.Z # insert latest version
----

Now let's add a small program to `fnl/my-plugin/init.fnl`.

[source,clojure]
----
(module my-plugin.init)

(print "Hello, World!")
----

We can compile the plugin using another helper script which will write into the `lua` directory, you should commit that output so that users of your plugin don't have to know it was ever written in Fennel in the first place.

[source,bash]
----
deps/aniseed/scripts/compile.sh
----

Users can call into your plugin however and whenever they choose or you can add some sort of startup hook into `plugin/my-plugin.vim`.

[source,viml]
----
lua require('my-plugin.init')

" Prints: Hello, World!
----

=== Using Aniseed at runtime in a plugin

I've only shown how to use Aniseed at compile time, there's one extra step involved when you want to use Aniseed in the runtime of your plugin. You can use `deps/aniseed/scripts/embed.sh` to copy Aniseed's Lua into your Lua directory under a unique prefix.

The code will be modified to add a prefix that keeps this version of Aniseed local to your plugin. This technique allows multiple plugins to carry their own copies of Aniseed with them without any conflicts or inconsistencies.

[source,bash]
----
deps/aniseed/scripts/embed.sh aniseed my-plugin
----

We can then refer to our Aniseed copy from `my-plugin.init`.

[source,clojure]
----
(module my-plugin.init
  {require {a my-plugin.aniseed.core}})

(a.println {:msg "Hello, World!"})
----

== Unlicenced

The following files are excluded from my license and ownership:

 * `lua/aniseed/deps/fennel.lua`
 * `lua/aniseed/deps/fennelview.lua`
 * `lua/aniseed/deps/nvim.lua`

These files come from https://fennel-lang.org/[Fennel] and https://github.com/norcalli/nvim.lua[nvim.lua], *I did not write them*, all other files are from me and unlicenced. The aforementioned files should be considered under their respective project licences. They are copied into this repo to allow the plugin to work with systems that don't support symlinks correctly.

Find the full http://unlicense.org/[unlicense] in the `UNLICENSE` file, but here's a snippet.

____
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means.
____
