                                                                     *aniseed*
                     ___          _                    __~
                    /   |  ____  (_)_______  ___  ____/ /~
                   / /| | / __ \/ / ___/ _ \/ _ \/ __  /~
                  / ___ |/ / / / (__  )  __/  __/ /_/ /~
                 /_/  |_/_/ /_/_/____/\___/\___/\__,_/~

==============================================================================
CONTENTS                                                    *aniseed-contents*

    1. Introduction ............................. |aniseed-introduction|
    2. Examples ..................................... |aniseed-examples|
    3. Scripts ....................................... |aniseed-scripts|
    4. Plugins ....................................... |aniseed-plugins|
    5. Dotfiles ..................................... |aniseed-dotfiles|
    6. Macros ......................................... |aniseed-macros|
    7. Functions ................................... |aniseed-functions|
    8. Testing ....................................... |aniseed-testing|

==============================================================================
INTRODUCTION                                            *aniseed-introduction*

Aniseed bridges the gap between Fennel (a Lisp that compiles to Lua) and
Neovim. Allowing you to easily write plugins (|aniseed-plugins|) or
configuration (|aniseed-dotfiles|) in a Clojure-like Lisp with great runtime
performance.
https://fennel-lang.org/

Interactive evaluation as you work is provided by the sister plugin, Conjure.
https://github.com/Olical/conjure

A few scripts are provided to make writing build scripts and Makefiles for
your plugins as simple as possible (|aniseed-scripts|).

You'll also find a set of useful functions (|aniseed-functions|) and macros
(|aniseed-macros|) that Aniseed exposes to you. They're all modeled on
Clojure's API so they should be very familiar if you're already a Clojurian.

Once you're up and running you'll be able write a test suite for your Aniseed
based tools (|aniseed-testing|). Scripts are provided to make it easy to get
them running in CI or your terminal right away.

==============================================================================
EXAMPLES                                                    *aniseed-examples*

Aniseed provides module macros that make writing Lua modules as easy as
Clojure namespaces. Here's what a module looks like.
>
  (module my-module
    {;; Require other modules with aliases.
     require {a aniseed.core
              nvim aniseed.nvim}
  
     ;; Inline modules at compile time.
     include {some-dep my-other.dependency}})
  
  (def- some-private-value 2)
  
  (defn- some-private-fn [x]
    (* x some-private-value))
  
  (defn a-public-fn [x]
    (-> x
        (some-private-fn)
        (a.inc)))
  
  ;; Prevent this value being overwritten on each eval.
  (defonce- some-stateful-thing (some-dep.start-server!))
  
  (comment
    (a-public-fn 10) ;; => 21
    (some-private-fn 10) ;; => 20
    (set nvim.g.hello "world!"))
>
Some good examples of what you can do with Aniseed in practice:

 * https://github.com/Olical/conjure
 * https://github.com/Olical/nvim-local-fennel
 * https://github.com/Olical/dotfiles (Neovim configured with Aniseed)

==============================================================================
SCRIPTS                                                      *aniseed-scripts*

These helper scripts aim to make plugin development as easy as possible. If
they're not quite to your liking, feel free to copy and modify them in your
own projects.

All of them can be used from `deps/aniseed/scripts/*` once you have Aniseed
installed by `dep.sh`. You should download `dep.sh` into your `scripts`
directory since it's used to fetch Aniseed itself.

`scripts/dep.sh [user] [repo] [revision]`
  Clones a GitHub repo into `deps/{name}` if it's not there already. Will update
  the repository each time and ensure the right revision is checked out.
  When developing a plugin you'll want to manually copy this script into your
  own repositories `script` directory and use it to fetch Aniseed.
  Usage: `scripts/dep.sh Olical aniseed vX.Y.Z`

`scripts/embed.sh [dep name] [your module prefix]`
  Copies a dependency's Lua from deps (result of `dep.sh`) into your own Lua
  directory under a prefix directory. Then munges the dependency to replace
  all occurrences of the module paths with your unique project specific
  prefix.
  Usage: `deps/aniseed/scripts/embed.sh aniseed my-plugin-name`

`scripts/compile.sh`
  Compiles all Fennel code into Lua assuming you have Aniseed cloned into your
  `deps` directory via `dep.sh`.
  Usage: `deps/aniseed/scripts/compile.sh`

`scripts/test.sh`
  Executes all of your tests found in `test/fnl` using the Aniseed cloned by
  `dep.sh`. Will leave behind files in `test/lua` and `test/results.txt` that
  you'll want to git ignore. All test modules must end with `-test` (so the
  file names need to end with `-test.fnl`).
  Environment:
   * `PREFIX` - Inserted before the arguments to Nevoim.
   * `SUFFIX` - Inserted after the arguments to Neovim.
  Usage: `deps/aniseed/scripts/test.sh`

==============================================================================
PLUGINS                                                      *aniseed-plugins*

When writing a plugin with Aniseed you'll first need to fetch the `dep.sh`
script and place it in your own `scripts` directory. Then you can clone
the latest Aniseed version into your `deps` directory with.
>
  scripts/dep.sh Olical aniseed vX.Y.Z
>
Let's start by adding the following Fennel code to `fnl/my-plugin/init.fnl`.
>
  (module my-plugin.init
    {require {a my-plugin.aniseed.core}})

  (a.println "Hello, World!")
>
Now execute `deps/aniseed/scripts/compile.sh` to compile this Fennel into Lua
under the `lua` directory. Now your Fennel has been compiled to Lua but we
need to embed a copy of Aniseed for runtime use by your plugin (the
`my-plugin.aniseed.core` module doesn't exist until we do this!).
>
  deps/aniseed/scripts/embed.sh aniseed my-plugin

Since running `compile.sh` and `embed.sh` every time you make a change is
quite tedious, you should be using Conjure for interactive evaluation as you
work and wrapping up your compile step in your own script or `Makefile`.
>
I'd recommend committing the compiled Lua so that your users can use your
plugin without any sort of compile step.

Your users can require your plugin as a Lua module whenever they want to, or
you can put an initialisation script in `plugin/my-plugin.vim` that does it
for them on startup.
>
  lua require("my-plugin.init")
>
Once your plugin is taking shape you'll probably want to have a look at
|aniseed-testing| to provide some automated tests locally or in CI.
>
==============================================================================
DOTFILES                                                    *aniseed-dotfiles*

If you want to replace your Neovim configuration in your dotfiles with Fennel
instead of Vim Script or Lua, you can do so by requiring the
`aniseed.dotfiles` module in your `init.vim` after Aniseed is installed.
>
  lua require('aniseed.dotfiles')
>
You can now add as much Fennel as you want to
`~/.config/nvim/fnl/dotfiles/init.fnl`. Let's add a simple greeting.
>
  (module dotfiles.init
    {require {a aniseed.core}})
  
  (a.println "Hello, World!")
>
Next time you open Neovim you'll see "Hello, World!" in `:messages`! You can
grow your configuration by adding more modules under `fnl/dotfiles` and
requiring them into your `dotfiles.init` module.

The Fennel will be compiled into `~/.config/nvim/lua` on startup whenever it
changes, so you may want to add that to your git ignore.

==============================================================================
MACROS                                                        *aniseed-macros*

Fennel and Lua don't have a well defined way of creating modules and exposing
some things while keeping others private. Clojure has a nice way of describing
this in the form of `def` forms and namespaces, we get something similar here.

Aniseed throws out Fennel and Lua's notion of `local`, `fn` and returning a
table from the bottom of your file and replaces them with it's own well
defined module syntax. The result is a normal Lua module, the way you define
it is just very different to what you may have seen before.

Not only does this make it a lot easier to require and export values from your
module, it also allows tools like Conjure to evaluate your code within the
right context.

`(module [name] [requires and imports] [base table])`
  This form should be the first thing in your file. The name should be exactly
  what you'd use to require your module, so `fnl/foo/bar.fnl` would have a
  name of `foo.bar` and could be required in Lua with `require("foo.bar")`.

  The second argument is an optional table that allows you to require or
  include other modules, the key is a function (`require` or `include` for
  example) and the value is another table mapping an alias to a module name.

  The final optional argument is a base table you would like Aniseed to merge
  your modules properties into, this can be useful for extending an existing
  module.
  >
    (module foo.bar
      {require {a aniseed.core}
       include {baz foo.baz}}
      {:xyz "this will be the base table that gets exported"})

`(def [name] [value])`
  Define a public value in the current module.
  >
    (def my-value {:foo :bar})
    (a.get my-value :foo) // => "bar"

`(def- [name] [value])`
  The same as `def`, but private to your module, only functions and values
  within you module can access it.

`(defonce [name] [value])`
  Like `def` but will only be defined once. Useful for defining stateful
  values that you don't want reset every time you evaluate the file with
  Conjure. You can store things like window or process IDs in here.

`(defonce- [name] [value])`
  Again, like `defonce` but isn't exposed publicly to everyone using your
  module. Only internal values and functions in your module have access.

`(defn [name] [...])`
  Just like Lua's built in `fn` but the result is defined using `def`. So it
  takes a name, argument list and optional documentation string.
  >
    (defn add [a b]
      "Adds two numbers together."
      (+ a b))

`(defn- [name] [...])`
  The same as `defn` but the function is private and only accessible within
  your module.

`(deftest [name] [...])`
  See |aniseed-testing| for more on testing, but this is used to define tests
  with `-test` suffixed modules for use with the `test.sh` test runner. It's a
  bit like `defn` but you also get access to the `t` assertion table, as
  described in the testing section.

==============================================================================
FUNCTIONS                                                  *aniseed-functions*

TODO

==============================================================================
TESTING                                                      *aniseed-testing*

Aniseed tests itself with it's own testing tools, so you can see an example
inside this very repository. We start by creating a module within our project
such as `fnl/foo/math.fnl`.
>
  (module foo.math)
  
  (defn add [a b]
    (+ a b))
>
We can then create our test module in `test/fnl/foo/math-test.fnl`.
>
  (module foo.math-test
    {require {math foo.math}})
  
  ;; The `t` assertion table is included automatically via the deftest macro.
  (deftest add
    (t.= 10 (math.add 6 4) "it adds things together"))
>
All of the tests can then be executed using the helper script which will
startup Neovim, execute the tests, capture the results and finally display
them in stdout. It exits with an appropriate status code for use with CI
systems (you'll need to ensure `nvim` is available inside your CI).

You'll want to git ignore `/test/lua/` and `/test/results.txt`. Provide a
`SUFFIX` or `PREFIX` environment var to prepend or append code to the `nvim`
command.
>
  deps/aniseed/scripts/test.sh
>
The `t` assertion table that's defined for you contains a few assertion
functions.

`(t.= expected result [description])`
  Check for an expected result.

`(t.pr= expected result [descrpition])`
  The same but both values will be serialised to a string before comparison,
  this allows you to compare deeply nested tables.

`(t.ok? result [description])`
  Check for some truthy value.

vim:tw=78:sw=2:ts=2:ft=help:norl:et:listchars=
